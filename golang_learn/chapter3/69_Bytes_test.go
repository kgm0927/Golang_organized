package chapter3

import "fmt"

/*
문자열은 읽기 전용이기 때문에 "가나다"를 "각나다"로 바꾸고자 다음과 같이 바이트를 조작하는 것은
불가능하다.

s:="가나다"
s[2]++
fmt.Println(s)

그러나 문자열을 아예 바이트 단위의 슬라이스로 변환할 수도 있다. '배열'은 동일한 데이터 형식이
연속적은 메모리 공간에 들어가 있는 구조이고, '슬라이스'는 배열을 좀 더 유연하게 만든 구조이다.

rune이 int32의 별칭이듯이 byte형은 uint8의 별칭이다. 각각 32비트 부호 있는 정수와 8비트 부호 없는
정수이다. 형 변환은 []byte(s)와 괕이 문자열s를 byte 슬라이스로 형 변환할 수 있다.

8비트 정수 슬라이스에서 다시 문자열로 변환하고자 할 대에는 string(b)와 같이 해주면 바이트 슬라이스인 b를
문자열로 형변환해 준다.


*/

func Example_modifyBytes() {
	b := []byte("가나다")
	b[2]++
	fmt.Println(string(b))
	// Output:
	// 각나다
}

/*

Go 언어의 문자열이 위의 함수처럼 반드시 UTF-8로 인코딩될 필요는 없다. 그러나 range를 이용하면
UTF-8로 디코딩된 유니코드 포인트를 하나씩 가져와서 처리하고, Go의 소스 코드 자체가 정의상 UTF-8로
인코딩되어 있어야 하기 때문에 소스 코드 내에 큰다옴표로 둘러싸인 문자열 리터럴은 UTF-8로 인코딩되는 것이
되며, fmt.Println()과 같은 함수들을 이용하면 UTF-8 환경에서 출력하게 됨녀 UTF-8로 인코딩 된 문자열이 제대로
화면에 출력이 된다.

굳이 UTF-8로 인코딩되어 있지 않은 문자열을 string으로 처리할 일은 많지 않으며, 대부분은 byte[]를 이용하여 처리하는
것이 좋다. 어떤 문자들이 있는지를 중시하면 string, 실제 바이트 표현이 어떤지를 중시하면 []byte를 이용하는 것으로 습관을
붙여도 될 것 같다.

*/
