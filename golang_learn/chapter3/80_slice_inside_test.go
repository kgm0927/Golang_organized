package chapter3

import "fmt"

/*
	슬라이스는 배열을 가리키고 있는 구조체라고 볼 수 있다.
	슬라이스는 3개의 필드들로 이루어져 있다. 시작 주소, 길이, 용량이다.
	그러니 여러 슬라이스가 동일한 배열을 공유할 수 있는 것이다. 복사가 일어나서
	이동이 일어났다고 했을 때에는 그 슬라이스는 이제 다른 배열을 보고 있게 된다.


	이러한 이유로 append에서 두번 반복해서 써주어야하는 이유가 나온다.

	nums=append(nums,10)

	이렇게 10을 뒤에 하나 추가하는 경우는 일단 nums의 늘어난 길이가 용량 초과를 할 것인지
	아닌지를 조사한다.

		1. len(nums)+1<=cap(nums), 즉, 용량을 초과하지 않은 경우다. 이 경우에는 시작 위치에서
		길이만큼 오른쪽으로 이동한 위치에서 새로운 값을 집어넣고, 길이가 증가한 슬라이스를 반환한다.
		그러니까 길아가 증가한 슬라이스를 nums에 할당해야 하므로 두 번 반복해서 써주어야 한다.const

		2. len(nums)+1>caps(nums), 즉 용량을 초과하게 될 경우이다. 이 경우에는 더 큰 크기의 배열을 새로
		하나 더 만들고 슬라이스로 맞게 고쳐서 반환한다. 마찬가지로 nums에 다시 할당해주어야 한다.


	따라서 어떤 경우라도 이 값을 받아야 한다. 이 값을 버리게 되면 원래 슬라이스에 길이가 늘어나지
	않으므로 실제 슬라이스는 덧붙이기가 일어나지 않게 된다. 고로 append한 것을 받지 않으면 컴파일
	오류가 발생할 것이다.

*/

func Example_sliceCopy() {
	src := []int{30, 20, 50, 10, 40}
	dest := make([]int, len(src))
	for i := range src {
		dest[i] = i
	}
	fmt.Println(dest)
	// Output: [30 20 50 10 40]
}

/*
	3.2.6 슬라이스 복사

	위의 함수에 한 가지 더 짚고 넘어갈 점은 위와 같이 슬라이스를 range로 반복했을 때, i 하나로 받았을 때
	값들, 그러니까 30,20,50,10,40이 들어가는 것이 아니다. 인덱스 번호가 들어가기 때문에 0,1,2,3,4가 들어가게
	된다. 익숙하지 않으면 실수할 수 있다.


	물론 이것은 귀찮은 방법이니, copy라고 하는 함수가 있는데 이것을 이용하면 된다. for문은 다음과 같이 바꿀 수 있다.


	copy(dest,src)



	그런데 src가 모두 복사될 정도로 dest 크기가 충분할까? 그래서 먼저 dest의 용량이 아니라 길이를 본다. 위에 간단히 for 문으로
	만든 복사 함수보다 더 복잡하게 있는데 len(src)와 len(dest) 중에서 더 작은 값만큼만 복사한다.

	실제로 몇 개가 복사가 되었는지 알아야 하므로 copy 함수는 몇 개가 복사되었는지 반환한다.

		if n := copy(dest, src); n != len(src) {
		fmt.Println("복사 덜 됨")
		fmt.Println(n)
	}


	여기서 재미있는 점은 if안에 조건에 세미콜론을 써서 구분은 할 수 있다. 위에서 n은 if 안에서 생성된 것이므로 if~else 밖으로 나가면
	소멸되어 접근할 수 없다.


	어쨌든 이 경우에는 복사가 모두 되지 않고 n개 만큼 복사가 일어나게 되었다는 것을 의미한다.
	그 n은 두 슬라이스 중 짧은 길이가 되는 것이다. 그래서 copy로 슬라이스 전체를 모두 복사하려면
	다음과 같이 해야 한다.


	src:=[]int{30,20,50,10,40}
	dest:=make([]int,len(src))
	copy(dest,src)


	copy는 서로 공간이 겹치는 두 슬라이스를 복사할 때도 사용할 수 있다. c언어에서 memcopy를 쓸 때
	영역이 겹치는지 신경을 써야 하는 것을 알 텐데, 이것은 memmove처럼 겹치는 영역을 복사하는데 쓸 수 있다.

	for 문을 이용하여 직접 복사하는 것보다 효율적일 것이다.const


	append 함수를 이용하여 간단히 복사된 슬라이스를 얻을 수 있다.

	src:=[]int{30,20,50,10,40}
	dest:=append([]int(nil),src ...)


	dest:=src 형태는 어떨까? 이 경우에는 슬라이스의 원소들이 복사되는 것이 아니라 배열 포인터, 길이, 용량이 복사되는 것이므로
	src의 원소들의 값을 변경하면 dest 원소들의 값도 변경된다.
*/
