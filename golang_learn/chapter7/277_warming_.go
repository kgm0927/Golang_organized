package chapter7

/*

	7.3.10 주의점


	이미 몇 당부 했듯이 보내는 쪽에서 채널을 닫는 것이 중요하다. 하지만 굉장히 많은 예제에서 이런
	실수를 범하고 있다. 그래서 예제를 보여 주도록 하겠다.


	// WARNING! This is a bad example.



	c:=make(chan int)
	done:=make(chan bool)
	go func(){
		for i:=0; i<10; i++{
			c<-i
		}
			done<-true

	}()

	go func(){
		for{
			fmt.Println(<-c)
		}
	}()
	<-done





	첫 번째 고루틴은 생산자이고 두 번째 고루틴은 소비자이다. 간단하게 생산자와 소비자가 하나씩 있는 코드이다.

	이 코드는 여러 가지 문제점이 있는데, 두 번째 고루틴이 끝나지 않는다는 점이다. 위의 코드가 반복적으로 수행될
	경우 고루틴의 수는 계속 늘어날 것이다.

	첫 번째 고루틴인 생산자에서는 생산이 끝난 다음에 done에 true 값을 넣어준다. 그리고 메인 고루틴은 <-done으로
	끝날 때까지 기다린다. 여기서 done은 생산이 끝난 뒤에 값이 들어가므로 소비가 끝나기 전에 메인 고루틴이 끝나버릴
	가능성이 있다. 위에서 아무리 fmt.Println(<-c)가 한 줄이라고 해도 <-로 받아와서 출력을 할 때 문맥 전환이 일어날
	수 있기 때문이다.

	혹은 이 다음 중에 다른 일을 더 해야 할 수도 있다. 따라서 운이 나쁘면 이 코드는 마지막 하나가 출력이 되지 않을 수도
	있다. 이렇게 코드를 만들면 나중에 버그가 발생했을 때 이유를 찾기 어렵다.



	자유롭게 고루틴과 채널을 이용하는 방법을 알려주기 보다는 정형화된 패턴을 위주로 알려주면서 자유롭게 활용할 수 있는 방법을
	익힐 수 있게 구성했다. 그렇게 구성한 이유가 이런 버그를 막기 위함이다.




	- 자료를 보내는 채널은 보내는 쪽에서 닫는다.

	- 보내는 쪽에서 반복문 등을 활용해서 보내다가 중간에 return을 할 수 있으므로 defer를 이용하는 것이 좋다. 그렇지 않으면
	return 했을 때 채널을 닫지 않고 종료할 수 있다.

	- 받는 쪽이 끝날때까지 기다리는 것이 모든 자료의 처리가 끝나는 시점까지 기다리는 방법으로 더 안정적이다.
	위의 예제에서는 생산자가 아닌 소비자 쪽에서 done<-true를 했어야 했다. 물론 위의 예제에서는 소비자 쪽에서
	언제 끝났는지 알 수 없다. 그것을 생산자에서 채널을 닫는 것으로 신호를 줬어야 했다.

	- 특별한 이유가 없다면 받는 쪽에서 ranage를 이용하는 것이 좋다. 생산자가 채널을 닫은 경우에 반복문을 빠져 나오게 되기
	때문에 편리하다.

	- 루틴이 끝났음을 알리고 다른 쪽에서 기다리는 것은 sync.WaitGroup을 이용하는 것이 나은 경우가 많다. 위의 예제와 같이
	간단한 경우가 아니라면 두 고루틴 모두가 끝날때까지 기다렸으면 문제가 없었을 것이다.


	- 끝났음을 알리는 done 채널은 자료를 보내는 쪽에서 결정할 사항이 아니다. 자료를 보내는 쪽에서는 채널을 닫아서 자료가
	끝났음을 알리는 것이 더 낫다. 그러면 done 채널은 받는 쪽에서 보내는 쪽에서 자료 전송이 끝났거나 끝나지 않았으면
	더 이상 자료를 보내지 말아달라는 cancel 요청으로 보는 것이 더 낫다.

	- done 채널에는 자료를 보내어 신호를 주는 많은 예제가 있는데, close(done)으로 채널을 닫는 것이 더 나은 방법인 경우가 많다.






	다른 하나의 주의점은 반복문 안에서 고루틴을 실행할 때이다. 이것은 병렬 for문이라고 볼 수 있다.
	// WARNING! This is a bad example.

	for i:=0; i<10; i++{
		go func(){
			fmt.Println(i)
		}()
	}


	이렇게 하면 고루틴 바깥의 i가 변하기에 고루틴 내에 있는 i도 변화하게 된다. 인자로 넘겨주어서
	복사가 일어나게 해야 한다.


	for i:=0;i <10;i++{
		go func(i int){
			fmt.Println(i)
		}(i)
	}




*/
