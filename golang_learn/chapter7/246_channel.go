package chapter7

/*
	위에서 활용한 메모리 및 파일 시스템을 공유하는 방법도 휼륭하지만, 고루틴끼리 서로 통신하기 위하여
	항상 이 방법을 이용할 수는 없을 것이다.


	채널(channel)은 넣은 데이터를 뽑아낼 수 있는 마치 파이프 같은 형태라고 생각하면 된다. 자료구조이며,
	채널에 데이터를 넣고 뽑을 수 있는데, 이것을 쓰면 서로 다른 고루틴 사이에 통신을 할 수 있다.


	채널은 기본 자료형으로 제공된다. 그렇기 때문에 채널 역시 일급 시민(first class citizen)이라고 할 수
	있다. chan int는 정수 채널형이 되며, 채널에는 양방향이 있고, 단방향이 있다. 양방향 채널은 자연스럽게 단방향
	채널로 변환해서 쓸 수 있다.

	채널은 맵처럼 생성해야 쓸 수 있다. '이 채널들을 복사하는 경우에 동일한 채널을 가리키는 것이 된다.' 따라서 채널은
	그 자체로 포인터와 비슷한 레퍼런스 형이라고 할 수 있다.
	맵 역시 마찬가지다. 그래서 make(chan int)와 같이 정수 채널을 만든다.


	c1:=make(chan int)
	var c2 chan int=c1			// 양방향
	var c3 <-chan int=c1		// 받기 전용
	var c4 chan<- int =c1		// 보내기 전용



	c1을 새로 정수 채널로 만들었다. c2를 다른 채널 변수에 c1을 할당한 것이다. c1과 c2는 동일한 채널이다.
	복사 시에 동일한 채널이므로 함수를 호출할 대 채널을 넘기면 함수 내에서 같은 동일한 채널에 값을
	넣거나 뺄 수 있다.


	c3의 자료형은 왼쪽으로 향하는 화살표가 chan 왼쪽에 붙어 있는데 이것은 자료를 뺄 수만 있다는 채널의 자료형이다.

	chan 오른쪽에 화살표가 붙어 있는 자료형으로 된 c4는 자료를 넣을 수만 있는 채널이다. 뺀다/넣는다를 좀더 우아한 말로
	바꿔보면 받는다/보낸다(receive/send) c3를 받기 전용(receive only), c4를 보내기 전용(send only) 채널이라고 한다.
	(아마도 이것을 상대편 입장에서 바라본 것 같다. 채널 자체의 입장에서는 이 표현이 '수동태'가 된다.)

	굳이 양방향 채널을 단방향으로 바꿀 이유가 있을까? 채널을 주고받을 때, 값을 받고 싶어서 넘기거나 주고 싶어서 넘기는 것을
	분명히 하고 싶을 때 좋다. 넘겨받는 함수에서 받는 채널은 반대 방향으로 이용할 수 없으니, 채널을 이용한 프로그래밍을 단순히
	하고, 실수를 방지해준다.

	채널 c에서 자료를 보낼 때에는 채널을 왼쪽에 두고 자료를 오른쪽에 둔 뒤 왼쪽 화살표로 이어준다. 아래는 채널 c에 100을 보낸 것이다.const

	c<-100


	반대로 채널 c에서 자료를 받을 때에는 채널 왼쪽에 왼쪽 화살표를 하나 붙여준다.

	c<-100

	그냥 위와 같이 쓰면 뺀 자료를 버리게 되므로 어딘가에 담거나 이용해야 한다.

	data:=<-c
*/
