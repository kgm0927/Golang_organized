package chapter7

/*
	7.3.2 채널 공유로 팬아웃하기

	이번에는 간단한 팬아웃*을 해 보겠다. 파이프라인은 앞의 과정에서는 결과물이 빨리 나오는
	데 뒤의 과정은 시간이 오래 결려서 여러 곳에 결과물을 나누어주어야 할 때 쓸 수 있다.

	방법은 간단하다. 채널 하나를 여럿에게 공유하면 된다. 여러 고루틴이 한 채널에서 자료를 받아가려고
	할 때, 보내는 쪽에서 자료를 보내면 하나의 고루틴에만 자료가 전달이 된다. 나머지는 계속 기다리고
	있게 될 것이다. 보내는 쪽에서 자료를 보내면 하나의 고루틴에만 자료가 전달이 된다. 나머지는 계속
	기다리고 있게 될 것이다.

	보내는 고루틴에서 자료 하나를 보냈을 때, 이 자료를 기다리고 있는 고루틴이 많다고 해도,
	그 많은 고루틴이 모두 같은 자료를 받는 구조가 아니다.


	일 다 끝났으니 다음 작업할 자료를 달라고 여러 명이 아우성이라도 자료 하나가 넘어오면 그 중에서
	한 명만 그 자료를 받아볼 수 있으니까. 위에서 알아본 PlusOne과 루틴의 구조적인 차이는 없다.
	보내는 쪽에서 모든 자료를 보내면 채널을 닫는 것도 동일하다. 채널이 닫히면 채널에서 자료를 받아가는 고루틴이
	몇 개인지와 상관없이 모든 고루틴이 채널이 닫혔음을 인지한다.



*/

/*package main

import (
	"fmt"
	"time"
)

func main() {
	c := make(chan int)
	for i := 0; i < 3; i++ {
		go func(i int) {
			for n := range c {
				time.Sleep(time.Second)
				fmt.Println(i, n)
			}
		}(i)
	}

	for i := 0; i < 10; i++ {
		c <- i
	}
	close(c)
}
*/

/*
	이번에는 지금까지의 예제들과 다르게 메인 고루틴이 보내는 역할을 한다. 먼재 채널을 하나 생성하고 첫 번째 for 반복문 안에서
	받는 고루틴들을 3개 생성한다. 각각의 고루틴은 자신의 고루틴 번호와 채널에서 넘어온 숫자를 출력한다. time.Sleep은 결과를
	좀 더 재미있게 하기 위하여 아주 짧은 시간 동안 잠을 자게 해서 다른 고루틴도 실행할 수 있도록 한다. 이렇게 하지 않으면
	한 고루틴이 독식하기 된다.


	이 프로그램이 복잡해보이지만 실질적으로는 하나의 for 반복문 안에서 순서대로 숫자를 출력하는 것과 기능적으로는 별반 다른 것이 없기
	때문에 굳이 여러 고루틴을 이용해서 돌아가면서 수행하지 않는다. 다시 기억해야 할 부분은 '고루틴들은 순차적으로 수행될 필요가 없는 것들'
	, 독립적으로 수행되어도 좋은 것들을 표현하지만 이것을 반드시 번갈아가면서 수행할 필요는 없다. 성능의 향상을 위하여 Go 컴파일러는 가능하면
	하는 일을 계속, 즉 수행하면 고루틴을 계속 수행하려고 노력할 것이다. 고루틴이 언제 문맥 전환이 되는지 뒤에서 알아보고, 지금 보는 time.Sleep은
	문맥 전환을 할 수 있는 경우 중 하나라는 것만 알아두면 된다.


	이제 위의 메인 함수에 대해서 설명할 것이다.
	보내는 부분은 그 뒤에 해당 채널로 0부터 9까지의 숫자들을 보낸다. 다 보낸 뒤에는 채널을 닫아 주었는데 여기서는 굳이 그럴 필요는 없지만 채널을
	다는 것은 아주 좋은 습관이다. 여기서 채널을 닫지 않아도 프로그램이 종료되지만 여기서 만약 프로그램이 종료되지 않은 경우에는 숫자들이 기다리는
	3개의 고루틴이 종료되지 않아서 계속 메모리에 남게 된다. 오랫동안 동작하는 서버 프로그램에서 이런 실수를 하게 되면 시간이 흐를수록 고루틴의 수가
	점점 늘어나게 되어 메모리 누수가 발생하게 된다.

*/
