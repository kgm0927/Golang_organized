package chapter7

import "fmt"

func Example_simpleChannel() {
	c := make(chan int)

	go func() {
		c <- 1
		c <- 2
		c <- 3
	}()

	fmt.Println(<-c)
	fmt.Println(<-c)
	fmt.Println(<-c)
	// Output:
	// 1
	// 2
	// 3
}

/*
	go func()로 호출된 고루틴 네에서는 1,2,3을 채널을 보내고, 밖에서는 받았다. 밖에 있는 fmt.Println()은
	고루틴을 분기하지는 않았지만 이것을 메인 고루틴이라 본다면 채널이 고루틴 사이에서 서로 데이터를 주고받는
	모습니다.

	그런데 이렇게 하면 보내는 고루틴과 받는 고루틴이 서로 몇 개의 데이터를 보내는지 알아야한다. 숫자가 맞지 않으면
	고루틴이 멈춘다. 그러니까 보내는 고루틴과 받는 고루틴이 주고받는 부분의 코드를 실행하고 있어야 서로 전달이
	이루어진다.

	보내는 고루틴에서 c<-1에 왔는데 받는 부분은 아직 <-c에 와 있지 않다면 보내는 고루틴은 거기서 멈춘다. 그리고 채널
	을  보낼 때 보내지지 않으면 다른 고루틴으로 문맥 전환(context switching)을 한다. 즉, 하던 일을 계속 할 수 없으니
	딴 고루틴으로 제어를 넘긴다는 것이다. 반대로 받는 고루틴에서는 <-c에 와 있는데 보내는 고루틴에서 보내는 코드에 와
	있지 않는다면 역시 마찬가지 일이 발생한다.



*/

/*
그러면 이제 보내는 부분과 받는 부분이 서로 데이터의 개수를 알지 못하더라도 동작하도록 코드를 만들어 본다.
*/

func Example_simpleChannel2() {
	c := make(chan int)

	go func() {
		c <- 1
		c <- 2
		c <- 3
		close(c)
	}()

	for num := range c {
		fmt.Println(num)
	}
	// Output:
	// 1
	// 2
	// 3
}

/*
	아까 전과 달라진 것이 있다면 보내는 쪽에서는 close(c)로 채널을 마지막에 닫아주었고, 받는 쪽에서는 for 반복문을
	통하여 데이터를 가져온다.

	채널 하나를 만들어서 넘겨주고 받는 것이 깔끔해보이지 않기 때문에 주로 함수가 채널을 반환하게 하는 패턴을 쓰기 한다.
	그리고 close는 defer를 사용하면 깔끔하다.

*/

func Example_simpleChannel3() {
	ch := func() <-chan int {
		c := make(chan int)
		go func() {
			defer close(c)
			c <- 1
			c <- 2
			c <- 3
		}()
		return c
	}()

	for num := range ch {
		fmt.Println(num)
	}

	// Output:
	// 1
	// 2
	// 3
}

/*
	자주 쓰이는 패턴이니 익혀두면 된다. 위의 코드의 보내는 쪽에서는 단방향 채널을 반환하여
	이 채널을 이용하는 고루틴이 받아가기만 하면 할 수 있게 제한하였다.

	그렇지 않고 받아가야 하는 곳에서 이 채널에 값을 보내려고 시도하면 그 자료를 받아가는 고루틴이
	없어서 영원히 프로그램이 멈추어 있을 수도 있기 때문이다.

*/
