package chapter7

/*
	지금까지 우리가 알아본 채널은 버퍼가 없는 채널이다. 보내는 고루틴에서 버퍼가 없는 채널에 값을
	보낼 때, 받는 쪽도 준비가 되어 있어야 한다.

	따라서 지금까지 봐왔던 채널 예제들은 물리적으로 동시에 수행되지 않는 경우가 많다. 채널에서
	값을 받는 부분에 도달하면 그제서야 채널로 보내는 고루틴의 코드로 건너 뛰어서 보내는 값을 생성하여
	받아도 되고, 마찬가지로 채널을 보내는 부분에 도달하면 그제서야 채널을 받는 부분으로 건너뛰어도
	되는 것이다. 클로저를 이용한 생성기와 비슷한 방식으로 동작하는 것이다.



	어쨌는 받는 준비가 되어 있지 않아도 보내는 쪽이 미리 보내고 싶으면 채널에 버퍼를 잡아주면 된다.

	c:=make(chan int, 10)

	위와 같이 버퍼의 크기가 10인 정수 채널을 만들었다. 단순히 채널 생성 부분만 저렇게 바꾸어도 되기 때문에
	무청 간편하다. 경우에 따라 버퍼 있는 채널을 만들면 성능상의 장점이 있다. 보내는 쪽과 받는 쪽의 코드가
	균일한 속도로 수행되지 않는 경우이다. 보내는 고루틴에서 패턴을 찾아서 보내주고, 받는 쪽에서 저장한다고
	가정해보자.

	사실 입출력 역시 한꺼번에 이루어지는 경우가 많지만, 입출력은 균일한 속도로 이루어진다고 해도, 패턴에 맞는
	결과가 몰려 있을 수도 있고 듬성듬성 나타날 수도 있다. 이때 버퍼를 만들어주면 이 두 고루틴 간에 어느 정도
	격차가 생겨도 계속 동작할 수 있기 때문에 성능향상이 일어날 수 있다.

	채널에 버퍼가 있으면 버퍼가 찰 때까지는 계속 집어넣을 수 있으므로 보내는 곳과 받는 곳이 서로 다른 고루틴이
	아니어도 된다.


	// Working but bad example.
	c:=make(chan int,1)
	c<-5
	fmt.Println(<-c)


	그러나 논리적인 오류 등으로 인해 버퍼가 가득 차게 된다면 다른 고루틴이 채널에서 받아가지 않는 이상, 고루틴이
	채널에 보내는 곳에서 영원히 멈추어버리기 때문에, 좋은 예제는 아니다. 막히면 버퍼 크기를 더 늘리는 식으로 문제를
	해결하면 코드가 점점 더 복잡해지고 예측 불가능한 코드가된다.

	버퍼 없는 채널로 동작하는 코드를 만들고 필요에 따라 성능 향상을 위해 버퍼 값을 조절하는 것이 좋다.
*/
