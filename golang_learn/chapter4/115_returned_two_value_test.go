package chapter4

/*

	4.1.2 둘 이상의 반환값


	Go 언어의 함수에서 둘 이상의 반환값을 둘 수 있다는 점이다.

	앞 장에서 WriteTo_2 함수에서 다음과 같이 에러 값 하나를 반환한다.

	func WriteTo(w io.writer,lines []string) error{}

	호출자가 이 함수가 노출되어 실제 몇 바이트를 썼는지 알고 싶을 때는 어떻게 해야 하는가?
	C언어 같은 경우 바이트 수를 반환하는 함수로 바꾼 뒤 음수 범위 값을 반환하여 에러를 표시한다던가
	따로 에러값을 받을 변수 주소 값은 넘겨주는 방법으로 처리해야 했다.

	둘 이상의 값을 반환할 수 있다면 쉽게 해결된다.

	func WriteTo(w io.Writer, lines[]string)(int64,error){}



	값을 받을 때에는 쉼표로 구분하여 반환값의 수에 맞게 받으면 된다. 버리고 싶은 값은 밑줄 문자를 이용하면
	된다. 아래의 예제는 int64 값은 관심이 없고 에러 값만 받고 싶을 때 받는 방법이다.


	4.1.3 에러 값 주고 받기


	하나의 값만 돌려받을 수 있는 경우에 에러값을 주고받기 위하여 여러 가지 어색한 방법을 이용해야 했다. 그중
	한가지 방법은, 정상적이지 않은 결과값을 돌려주는 방식으로 개수를 돌려주는 함수에서 음수를 돌려준다면 에러의 의미하는
	것으로 약속하는 것이다. 한 예시고 strings.Index에서 -1이 나올 경우 배열 안에서 그러한 문자열이 없다는 것을 의미한다.


	또 다른 방법은 호출하는 쪽에서 에러값을 받고 싶은 변수의 포인터나 레퍼런스를 함수로 남겨 주어서 받는 것이다.


	물론 패닉(panic)이라는 개념이 있어서 다른 언어들의 예외(expception)와 같은 것을 제공해 준다. 보통 예외를 던지면
	호출 스택에 따라 호출 역순으로 따라가면서 이 예외를 처리해줄 코드를 찾는다. 그러나 Go언어의 패닉은 일반적인 에러 상황에서
	쓰이는 것은 아니고 심각한 에러 상황에서 쓰인다. 패닉 없이 일반적인 흐름에서 에러를 처리할 수 있는 경우가 대부분이므로
	에러값을 돌려주는 방법에 대해 익숙해져야 된다.

	다만 에러를 돌려받아서 이용하는 코드들을 작성하다보면 반복적인 코드 양이 매우 많아진다. 그나마 다행인 것이 Go에서는 if문
	의 조건문을 다음과 같이 쓸 수 있다.

	if err:=MyFunc(); err!=nil{ ... }

	꼭 에러가 아니더라도 조건문 안에서 변수를 새로 만들고 조건문 안에서만 이용할 수 있다. 이 경우에 err 변수는 조건문 밖으로만
	벗어나면 소멸된다.

	예외는 발생한 곳에 처리할 수 있는 곳이 다른 경우가 많다. 문자열을 숫자로 변환하는 함수 내에서는 문자열에 숫자가 아닌 알파벳이
	들어가 있을 때, 어떻게 처리해야 할지 못한다. 그러나 이 함수를 호출한 함수나 그 함수를 호출한 더 상위의 함수는 제대로 입력하라는
	메시지와 함께 다시 입력을 받거나 하는 등의 처리 방법을 알 수 있다.
	예외를 던지고 처리하는 패턴이 이런 경우의 처리를 위한 것인데, Go의 방식이라면 예외를 현재 문맥에서 처리할 수 없을 때에는 해당 에러를 그대로
	반환할 수 있다. 예를 들어 하나와 에러 하나를 반환하는 함수 내에서 다음과 같이 에러를 호출자에게 떠넘길 수 있다.


	if err:=MyFunc(); err!=nil{

		return nil,err
	}

	새로운 에러를 생성해야 하는 경우에는 가장 간단한 방법으로 errors.New와 fmt.Errorf를 이용할 수 있다. 물론 더 자세한 구조와 정보를
	담아서 호출한 곳으로 돌려줄 수 있지만 가장 단순한 점은 문자열 메시지를 주는 것이다. 많은 경우 문자열 메시지는 로그 등으로 출력되는
	경우가 많아 메시지만 보고서 어디서 잘못되었는지 알기 어려우므로 반드시 문맥을 알기 쉽게 써 줘야 한다.

	stringlist.ReadFrom함수에서 줄이 너무 길어서 발생한 에러라는 것을 알 수 있다.

	return errors.New("stringlist.ReadFrom: line is too long")


	이런 에러가 ReadFrom 뿐만 아니라 같은 패키지에 안에 있는 다른 읽기 함수에서도 발생하는 경우가 많은데 이럴 때는 ReadFrom은 빼고 구성해도
	좋다. fmt.Sprint와 사촌이라고 할 수 있는 fmt.Errorf를 이용하면 다른 부가 정보를 추가한 메시지를 돌려줄 수 있다.

	return fmt.Errorf("stringlist: too long line at %d",count)

	단순한 메시지 이외의 에러 처리 방법에 대해서는 6.4.3 '에러 처리'에서 다룬다.
*/
