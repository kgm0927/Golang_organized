package chapter5

import (
	"testing"

	"github.com/AKA-bingo/GoCoPark/leetcode"
)

/*
		5.1.3 테이블 기반 테스트


	지금까지 책을 읽어오시면서 스스로 테스트를 작성하려고 했을 때 많은 불편함이 있다.
	이전에 다른 프로그램이 언어를 이용하여 프로그래밍을 하면서 어서션(assertion)을 이용한
	유닛 테스트를 해왔다면 제네릭(generic)을 지원하지 않은 Go 언어가 불편할 것이다.


	그런데 Go 언어에서는 제공하는 testing 패키지에는 파이썬의 assertEqual 처럼 같은 방식으로
	테스트할 수 있는 함수가 제공되지 않는다.


	제공되지 않아서 만들어보고 싶어서 다음과 같이 만들었다.
*/

func assertIntEqual(t *testing.T, a, b int) {
	if a != b {
		t.Errorf("assertion failed: %d!=%d", a, b)
	}
}

/*
	그런데 이 함수는 정수형만 비교할 수 있다. 새로운 자료형이 나타날 때마다 새로운 함수를 만들어야 한다.
	그리고 이 함수는 하는 일이 그렇게 많지 않다. 오히려 함수를 만들지 않고 그대로 if문을 쓰는 것이
	더 읽기 쉽다고 생각하는 사람이 많을 것이다.


	여러 사례를 테스트하고 싶을 때, 문제가 커진다. 입력이 이런 경우에 출력이 어떻게 되고, 다른 입력이 들어오면
	또 다른 출력이 되는 것을 테스트하고 싶은데 사례가 수십 가지가 될 수 있다.

	이때에 이 모든 사례에 대하여 테스트하고 if문을 계속 연달아 써주면 코드가 반복되는 것은 물론이요, 읽기도
	어렵게 된다. 이럴 때 구조체와 배열을 이용하여 테이블 기반 테스트를 할 수 있다.


*/

func TestFib(t *testing.T) {
	cases := []struct {
		in, want int
	}{
		{0, 0},
		{5, 5},
		{6, 8},
	}

	for _, c := range cases {
		got := leetcode.Fib(c.in)
		if got != c.want {
			t.Errorf("Fib(%d)==%d, want %d", c.in, got, c.want)
		}
	}
}

/*

	입력과 출력의 목록들만 따로 빼낸 다음에 이것을 이용해 테스트를 작성했다.
	assertEqual와 같은 함수를 사용하여 테스트하지 못해 불편했다면, 그 함수를
	직접 만들기 전에 단순히 if를 활용하면 어떤지, 아니면 테이블 기반 테스트를 이용하여
	어떤지 한 번 생각해 봐야한다.

*/

var flagtests = []struct {
	int string
	out string
}{
	{"%a", "[%a]"},
	{"%a", "[%-a]"},
	{"%+a", "[%+a]"},
	{"%#a", "[%#a]"},
	{"% a", "[% a]"},
	{"%0a", "[%0a]"},
	{"%+1.2a", "[%+1.2a]"},
	{"%-+1.2a", "[%+-1.2a]"},
	{"%-+12abc", "[%+-1.2a]bc"},
	{"%-1.2abc", "[%-1.2a]bc"},
}
