package chapter5

/*
	정렬 알고리즘


	그렇다면 sort.Sort는 어떤 알고리즘을 사용하는 것일까? 단순히 정렬된 자료를 원한다면 어떤 알고리즘을
	사용하는지는 잊어버려고 되지만, 설명을 해 보겠다.

	일반적으로 싱글 스레드에서 비교 정렬 알고리즘은 빠른 정렬(Quicksort)이 아주 훌륭하다. 많은 비교 정렬
	알고리즘들이 O(log n)의 시간 복잡도를 가지지만 잘 구현된 빠른 정렬은 평균적으로 가장 효율적으로 정렬할 수
	있다. 빠른 정렬은 O(n log n)의 평균 시간 복잡도를 가지지만 최악의 경우는 O(n^2)이 될 수 있다. 이를 극복하기
	위해 다양한 방법을 이용하는데 랜덤 피벗(random Pivot)을 뽑기도 하고 몇개의 피봇을 골라(sample)서 이용하기도
	한다.


	7개 이항의 값들에 대해서는 삽입 정렬(insertion sort)이 가장 효율적이다. 삽입 정렬은 O(n^2)의 시간 복잡도를 가지는
	비효율적인 알고리즘이지만 작은 크기의 자료에 대해서는 빠른 정렬보다 빠르다. 시간 복잡도의 점근 표기법(big-O notation)이
	어느 정도 이상으로 큰 자료에서 의미가 있다는 점을 생각해보면 당연하다.

	책을 집필하는 현재 soft.Sort에서는 기본적으로 빠른 정렬을 한다. 빠른 정렬의 최악의 경우를 피하기 위해 피벗 3개를 골라서
	가운데 값을 고르는 중위법을 이용한다. 그렇게 했지만 너무 깊이 빠른 정렬에 빠지게 되면 힙 정렬을 이용한다. 빠른 정렬을
	이용하다가도 7개 이하의 자료에 대하여 졍렬하는 상황을 만나면 삽입 정렬을 이용한다. 꽤 효율적으로 잘 구현되어 있다.



*/
