package chapter5

/*
	5.1.2 const와 iota

	개발자들은 자주 요구 사항이 변경되고 기능이 확장되는 일을 피할 수 없다. 사용자가 업데이트를 할 필요도 없이
	새로 고침을 하는 것만으로도 변경점이 적용되기 때문이다.


	확장성을 위한 한 가지 팁을 드리자면 bool형을 쓸 곳에 enum형을 쓰라는 것이다. 예를 들어 아까 전에 정의한 Task
	자료형을 보면 done 필드가 bool형으로 되어 있다. 할 일을 완료했다, 완료하지 못했다 라는 정보를 가지고 있다.
	현재 상황을 알지 못한다는 값을 추가한다고 하면 이것을 자료형 포인터로 만들 수 있을 것이다.
*/

type status int

/*
	새로 추가된 status 필드는 status라는 자료형으로 되어 있는데, 다음과 같이 int를 이름 붙여본다.

*/

/*type Task_2 struct {
	title  string
	status status
	due    *time.Time
}*/

/*
	이제 상태들을 정의해야 할 텐데, enum 자료형이 있는지 궁금할 것이다. Go에서는 enum에 따로 없고, 상수로 정의해서
	사용한다. 따라서 다음과 같이 쓰면 된다.

*/
/*
const (
	UNKNOWN status = 0
	TODO    status = 1
	DONE    status = 2
)


UNKNOWN은 굳이 쓸 필요가 없을 수 있지만, 기본값인 0을 이와 같은 더미(dummy) 값으로 두는 것이 여러모로 도움이 되는 경우가 많아서
이렇게 했다.

0,1,2를 순서대로 붙이면 고단한 작업이 될 수 있다. 그래서 다음과 같이 'iota'를 이용하면 편리하다.
*/

const (
	UNKNOWN status = iota
	TODO
	DONE
)

/*이렇게 하면 순서대로 0,1,2가 붙는다. 사실 한 번만 써줘도 된다.

이렇게 할 시 순서대로 0,1,2가 붙는 것은 물론이고 TODO와 DONE의 자료형 역시 status가 된다.
묶어서 쓸 때의 좋은 점이 바로 이런 것이다.


이 외에도 iota를 쓸 수 있는 방법은 많다. Effective Go에 나오는 상수 정의에 대한 예제가 있다.
*/

type ByteSize float64

const (
	_           = iota // ignore first value
	KD ByteSize = 1 << (10 * iota)
	MB
	GB
	TB
	PB
	EB
	ZB
	YB
)

/*

	iota가 0부터 시작하는데 첫 번째 값은 0은 버렸다. 앞에 상수 이름으로 밑줄을 쓰게 되면 아무 이름을 정의하지 않고
	버리는 것이 된다.

	다음 iota는 1이 되는데 단순히 iota를 쓰지 않고 1<<(10*iota)를 썼다. 이렇게 되면 KB의 값은 1<<(10*1)이 된다.
	<< 연산자른 비트를 왼쪽으로 이동시키는 연산자로 1을 왼쪽으로 10번 이동시키겠다는 것은 사실상 2의 10승인 1024가
	된다.

	KB의 값이 1024가 된다는 의미이다. 그 다음 MB는 뒤에 아무것도 붙어 있지 않지만 1<<(10*2)와 같이 해석되어
	2의 20승이 된다.

*/
